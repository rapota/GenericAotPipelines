using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;

namespace GenericAotPipelines.Generators;

internal static class CodeGeneration
{
    public static string GenerateDecorator(HandlerMetadata handlerMetadata)
    {
        StringBuilder builder = new();
        GenerateCode(builder, handlerMetadata);
        return builder.ToString();
    }

    private static void GenerateCode(StringBuilder builder, HandlerMetadata handlerMetadata)
    {
        using StringWriter writer = new StringWriter(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter source = new IndentedTextWriter(writer, "    ");

        GenerateFile(source, handlerMetadata);
    }

    private static void GenerateFile(IndentedTextWriter source, HandlerMetadata handlerMetadata)
    {
        source.WriteLine("// <auto-generated/>");
        source.WriteLine();
        source.WriteLine("#pragma warning disable");
        source.WriteLine("#nullable enable");
        source.WriteLine();

        source.WriteLine("using System;");
        source.WriteLine("using System.Threading;");
        source.WriteLine("using System.Threading.Tasks;");

        source.WriteLine();

        source.WriteLine($"namespace {handlerMetadata.HandlerType.Namespace}");
        source.WriteLine("{");
        source.Indent++;

        GenerateClass(source, handlerMetadata);

        source.Indent--;
        source.WriteLine("}");
    }

    private static void GenerateClass(IndentedTextWriter source, HandlerMetadata handlerMetadata)
    {
        var className = typeof(DecoratorGenerator).FullName;
        var assemblyVersion = typeof(DecoratorGenerator).Assembly.GetName().Version.ToString();

        source.WriteLine("[global::System.CodeDom.Compiler.GeneratedCode(\"{0}\", \"{1}\")]", className, assemblyVersion);
        source.WriteLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
        source.WriteLine($"partial class {handlerMetadata.HandlerType.TypeName}");
        source.WriteLine("{");
        source.Indent++;

        GenerateDecorator(source, handlerMetadata);

        source.Indent--;
        source.WriteLine("}");
    }

    private static void GenerateDecorator(IndentedTextWriter source, HandlerMetadata handlerMetadata)
    {
        //[GeneratedCode()]
        string decoratorName = handlerMetadata.HandlerType.TypeName + "Decorator";

        source.WriteLine($"private sealed class {decoratorName}");

        source.Indent++;
        source.WriteLine(
            ": global::GenericAotPipelines.PipelineDecorator<{0}>",
            Mappings.Format(handlerMetadata.InterfaceMetadata.RequestResponseTypes));
        source.WriteLine(
            ", {0}",
            Mappings.Format(handlerMetadata.InterfaceMetadata.InterfaceType));
        source.Indent--;

        source.WriteLine("{");
        source.Indent++;

        GenerateConstuctor(source, handlerMetadata, decoratorName);

        source.Indent--;
        source.WriteLine("}");
    }

    private static void GenerateConstuctor(IndentedTextWriter source, HandlerMetadata handlerMetadata, string decoratorName)
    {
        source.WriteLine($"public {decoratorName}(");
        source.Indent++;

        source.WriteLine("{0} pipeline,", Mappings.Format(handlerMetadata.AttributeMetadata.PipelineType));

        source.WriteLine($"{handlerMetadata.HandlerType.TypeName} handler)");
        source.WriteLine(": base(pipeline, handler)");

        source.Indent--;
        source.WriteLine("{}");
    }
}